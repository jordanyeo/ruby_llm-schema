# frozen_string_literal: true

module RubyLLM
  class Schema
    # Expands compressed field names back to original names using a field_map
    # generated by the Compressor.
    #
    # @example
    #   field_map = { "a" => :first_name, "b" => :last_name }
    #   response = { "a" => "John", "b" => "Doe" }
    #   expanded = Expander.expand(response, field_map)
    #   # => { first_name: "John", last_name: "Doe" }
    #
    class Expander
      class << self
        # Expands a compressed response using the field_map
        #
        # @param response [Hash] The response from the LLM with compressed field names
        # @param field_map [Hash] The field_map from Compressor.compress
        # @param symbolize [Boolean] Whether to symbolize keys (default: true)
        # @return [Hash] The response with original field names restored
        def expand(response, field_map, symbolize: true)
          return response unless response.is_a?(Hash) && field_map.is_a?(Hash)

          defs = field_map[:_defs] || field_map["_defs"]
          expand_hash(response, field_map, defs, symbolize: symbolize)
        end

        private

        def expand_hash(hash, field_map, defs, symbolize:)
          result = {}

          hash.each do |key, value|
            mapping = field_map[key] || field_map[key.to_s]

            if mapping.nil?
              # Key not in field_map, preserve as-is
              result[key] = value
            elsif mapping.is_a?(Symbol) || mapping.is_a?(String)
              # Simple mapping
              expanded_key = symbolize ? mapping.to_sym : mapping.to_s
              result[expanded_key] = value
            elsif mapping.is_a?(Hash)
              # Complex mapping (nested object, array, variants, or ref)
              original = mapping[:_original] || mapping["_original"]
              expanded_key = symbolize ? original.to_sym : original.to_s

              result[expanded_key] = expand_value(value, mapping, defs, symbolize: symbolize)
            end
          end

          result
        end

        def expand_value(value, mapping, defs, symbolize:)
          # Handle array with _items mapping
          if mapping[:_items] || mapping["_items"]
            items_map = mapping[:_items] || mapping["_items"]
            return expand_array(value, items_map, defs, symbolize: symbolize)
          end

          # Handle $ref mapping
          if mapping[:_ref] || mapping["_ref"]
            ref_name = mapping[:_ref] || mapping["_ref"]
            ref_map = defs && (defs[ref_name] || defs[ref_name.to_sym])
            if ref_map
              if value.is_a?(Array)
                return value.map { |item| expand_hash(item, ref_map, defs, symbolize: symbolize) }
              else
                return expand_hash(value, ref_map, defs, symbolize: symbolize)
              end
            end
            return value
          end

          # Handle anyOf/oneOf variants
          if mapping[:_variants] || mapping["_variants"]
            variants = mapping[:_variants] || mapping["_variants"]
            return expand_with_variants(value, variants, defs, symbolize: symbolize)
          end

          # Handle nested object (has field mappings directly)
          if value.is_a?(Hash)
            # Filter out metadata keys to get actual field mappings
            nested_map = mapping.reject { |k, _| k.to_s.start_with?("_") }
            return expand_hash(value, nested_map, defs, symbolize: symbolize)
          end

          value
        end

        def expand_array(array, items_map, defs, symbolize:)
          return array unless array.is_a?(Array)

          array.map do |item|
            if item.is_a?(Hash)
              expand_hash(item, items_map, defs, symbolize: symbolize)
            else
              item
            end
          end
        end

        def expand_with_variants(value, variants, defs, symbolize:)
          # Handle array values - find the array variant and expand items
          if value.is_a?(Array)
            # Find a variant that has _items (indicating it's an array variant)
            array_variant = variants.find do |variant|
              next if variant.nil? || variant.empty?
              variant[:_items] || variant["_items"]
            end

            if array_variant
              items_map = array_variant[:_items] || array_variant["_items"]
              return expand_array_with_nested_map(value, items_map, defs, symbolize: symbolize)
            end

            return value
          end

          return value unless value.is_a?(Hash)

          # Find the matching variant by detecting which keys are present
          matching_variant = variants.find do |variant|
            next if variant.nil? || variant.empty?
            # Skip array variants when looking for object matches
            next if variant[:_items] || variant["_items"]
            variant.keys.any? { |k| !k.to_s.start_with?("_") && (value.key?(k) || value.key?(k.to_s)) }
          end

          if matching_variant
            expand_hash(value, matching_variant, defs, symbolize: symbolize)
          else
            value
          end
        end

        def expand_array_with_nested_map(array, items_map, defs, symbolize:)
          return array unless array.is_a?(Array)

          # items_map could be a direct field mapping or contain nested _variants/_items
          array.map do |item|
            if item.is_a?(Hash)
              if items_map[:_variants] || items_map["_variants"]
                # Nested anyOf/oneOf inside array items
                variants = items_map[:_variants] || items_map["_variants"]
                expand_with_variants(item, variants, defs, symbolize: symbolize)
              else
                # Direct field mapping
                expand_hash(item, items_map, defs, symbolize: symbolize)
              end
            else
              item
            end
          end
        end
      end
    end
  end
end
